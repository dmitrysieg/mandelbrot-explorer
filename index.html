<!DOCTYPE html>
<html>
    <head>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/103/three.min.js"></script>
    </head>
    <body>

        <style>
            body {
                width: 100%;
                height: 100%;
                margin: 0;
                overflow: hidden;
            }
            .info-label {
                position: absolute;
                color: #fff;
                top: 8px;
                left: 8px;
                font-family: monospace;
            }
        </style>

        <div class="info-label"><!-- --></div>

        <script id="mandelbrot-vertex" type="x-shader/x-vertex">
            precision highp float;
            uniform float zoom;
            uniform vec2 translate;
            varying vec2 pos;

            void main () {
                pos = position.xy * zoom + translate;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        </script>

        <script id="mandelbrot-fragment" type="x-shader/x-fragment">
            precision highp float;
            varying vec2 pos;
            const int MAXITER = 1000;

            // All components are in the range [0..1], including hue.
            vec3 hsv2rgb(in vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            void main () {
                vec2 fractal = pos;
                vec4 color;

                bool diverged = false;
                for (int i = 0; i < MAXITER; i++) {
                    fractal = pos + vec2(
                        fractal.x * fractal.x - fractal.y * fractal.y,
                        2.0 * fractal.x * fractal.y
                    );

                    float nsmooth = (float(i) + 1.0 + log(length(fractal))) / float(MAXITER);
                    // interpolate fractal color over position
                    color = vec4(hsv2rgb(vec3(nsmooth, 1.0, 0.5)), 1);

                    // if outside of fractal, use black
                    if (length(fractal) > 1.5) {
                        diverged = true;
                        break;
                    }
                }
                if (!diverged) {
                    color = vec4(0, 0, 0, 1);
                }

                gl_FragColor = vec4(color);
            }
        </script>

        <script type="text/javascript">
            var width = window.innerWidth;
            var height = window.innerHeight;

            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.z = 1;

            // create canvas
            var renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setSize(width, height);
            document.body.appendChild(renderer.domElement);

            // create mandelbrot mesh
            var geometry = new THREE.PlaneGeometry(2, 2, 0);
            var material = new THREE.ShaderMaterial({
                uniforms: {
                    zoom: {type: 'f', value: 2.0},
                    translate: {type: 'vec2', value: new THREE.Vector2(0.0, 0.0)}
                },
                vertexShader: document.getElementById('mandelbrot-vertex').innerHTML,
                fragmentShader: document.getElementById('mandelbrot-fragment').innerHTML
            });
            var mesh = new THREE.Mesh(geometry, material);

            scene.add(mesh);

            var zoomSpeed = 0.0,
                zoomAcceleration = 0.0,
                zoomAccelerationInc = 2.0 * 0.35,
                k_frict = 0.4,
                k_delta = 0.01;
            var pan_speed = 1.0;

            function sign(v) {
                return v > 0 ? 1 : (v < 0 ? -1 : 0);
            }



            var isMouseDown = false,
                dragPosition = null,
                _translate = null;
            function onDocumentMouseDown(e) {
                isMouseDown = true;
                dragPosition = [
                    e.pageX / window.innerWidth * pan_speed * material.uniforms.zoom.value,
                    e.pageY / window.innerHeight * pan_speed * material.uniforms.zoom.value
                ];
                _translate = material.uniforms.translate.value;
            }
            function onDocumentMouseMove(e) {
                if (isMouseDown) {
                    var _position = [
                        e.pageX / window.innerWidth * pan_speed * material.uniforms.zoom.value,
                        e.pageY / window.innerHeight * pan_speed * material.uniforms.zoom.value
                    ];
                    var _delta = new THREE.Vector2(-(_position[0] - dragPosition[0]), _position[1] - dragPosition[1]);
                    var translateNew = _translate.clone();

                    material.uniforms.translate.value = translateNew.add(_delta);
                }
            }
            function onDocumentMouseUp(e) {
                isMouseDown = false;
                dragPosition = null;
                _translate = null;
            }
            function onDocumentMouseWheel(e) {
                zoomAccelerationInc = material.uniforms.zoom.value * 0.35;
                zoomAcceleration = -sign(e.wheelDeltaY) * zoomAccelerationInc;
            }

            document.addEventListener('mousewheel', onDocumentMouseWheel, false);
            document.addEventListener('mousedown', onDocumentMouseDown, false);
            document.addEventListener('mousemove', onDocumentMouseMove, false);
            document.addEventListener('mouseup', onDocumentMouseUp, false);

            var prevTime = 0.0;
            function render (time) {
                requestAnimationFrame(render);

                if (time) {
                    var delta = (time - prevTime) * k_delta;

                    var _zoomSpeed = zoomSpeed;
                    zoomSpeed += delta * (
                        // total acceleration
                        zoomAcceleration +
                        (-k_frict * zoomSpeed)
                    );
                    if (sign(_zoomSpeed * zoomSpeed) < 0/* || Math.abs(zoomSpeed) < 10e-4*/) {
                        zoomSpeed = 0.0;
                    }
                    zoomAcceleration = 0.0;

                    var _zoom = material.uniforms.zoom.value;
                    var newZoom = _zoom + zoomSpeed * delta;
                    console.log('%c' + _zoom + ' ' + newZoom, 'color: #ff0000');

                    if (sign(newZoom) < 0) {
                        newZoom = _zoom;
                    }
                    material.uniforms.zoom.value = newZoom;

                    document.getElementsByClassName('info-label')[0].innerHTML = material.uniforms.zoom.value;
                    prevTime = time;
                }
                renderer.render(scene, camera);
            }

            render();
        </script>
    </body>
</html>
